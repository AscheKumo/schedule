<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Am I Working?</title>
  <style>
    :root {
      --bg: #000;
      --fg: #ddd;
      --red: #ff3b3b;
      --green: #37d67a;
      --blue: #4aa3ff;
      --muted: #9aa0a6;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { height: 100%; display: grid; place-items: center; text-align: center; padding: 24px; }
    #status { font-size: clamp(44px, 8vw, 110px); font-weight: 800; letter-spacing: 0.5px; margin: 0; }
    #sub { margin-top: 14px; font-size: clamp(18px, 2.2vw, 28px); color: var(--muted); }
    #extra { margin-top: 14px; font-size: clamp(16px, 2vw, 22px); color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <h1 id="status">...</h1>
      <div id="sub">...</div>
      <div id="extra"></div>
    </div>
  </div>

<script>
/**
 * =========================
 * CONFIG (EDIT THIS SECTION)
 * =========================
 */
const CONFIG = {
  timeZone: "America/Denver",

  workStart: { h: 8,  m: 0 },
  workEnd:   { h: 17, m: 0 },

  sleepAfterHour: 23,

  holidays: {
    fixed: [
      { name: "New Year's Day", month: 1,  day: 1  },
      { name: "Independence Day", month: 7, day: 4  },
      { name: "Christmas Day", month: 12, day: 25 },
    ],
    floating: [
      { name: "Memorial Day", month: 5,  weekday: 1, occurrence: "last"  },
      { name: "Labor Day",    month: 9,  weekday: 1, occurrence: 1       },
      { name: "Thanksgiving", month: 11, weekday: 4, occurrence: 4       },
      { name: "Day After Thanksgiving", month: 11, relativeTo: "Thanksgiving", offsetDays: 1 },
    ],
    christmasEveHalfDay: true,
    christmasEveEnd: { h: 17, m: 0 },
  },

  timeOff: [
    // { start: "2026-01-15", end: "2026-01-20", label: "Vacation" },
  ],
};

const $status = document.getElementById("status");
const $sub = document.getElementById("sub");
const $extra = document.getElementById("extra");

// Get parts in the configured timezone using Intl
function tzParts(date, timeZone) {
  const dtf = new Intl.DateTimeFormat("en-US", {
    timeZone,
    year: "numeric", month: "2-digit", day: "2-digit",
    hour: "2-digit", minute: "2-digit", second: "2-digit",
    hour12: false,
    weekday: "short",
  });
  const parts = dtf.formatToParts(date);
  const get = (type) => parts.find(p => p.type === type)?.value;
  return {
    year: +get("year"),
    month: +get("month"),
    day: +get("day"),
    hour: +get("hour"),
    minute: +get("minute"),
    second: +get("second"),
    weekday: get("weekday"),
  };
}

function pad(n) { return String(n).padStart(2, "0"); }
function ymd({year, month, day}) { return `${year}-${pad(month)}-${pad(day)}`; }
function cmpYMD(a, b) { return a < b ? -1 : a > b ? 1 : 0; }

// Build a Date that corresponds to a local time in the target timezone.
function dateFromTZLocal({year, month, day, hour, minute, second=0}, timeZone) {
  const guess = new Date(Date.UTC(year, month-1, day, hour, minute, second));
  for (let step = -24; step <= 24; step++) {
    const d = new Date(guess.getTime() + step * 60 * 60 * 1000);
    const p = tzParts(d, timeZone);
    if (p.year===year && p.month===month && p.day===day && p.hour===hour && p.minute===minute) {
      return d;
    }
  }
  return guess;
}

function isWeekend(weekdayShort) { return weekdayShort === "Sat" || weekdayShort === "Sun"; }
const WEEKDAY_TO_NUM = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };

function daysInMonth(year, month) {
  return new Date(Date.UTC(year, month, 0)).getUTCDate();
}

function computeFloatingHolidayYMD(year, rule, timeZone) {
  const month = rule.month;
  const targetWeekday = rule.weekday;
  const dim = daysInMonth(year, month);

  if (rule.occurrence === "last") {
    for (let d = dim; d >= dim - 6; d--) {
      const dt = dateFromTZLocal({year, month, day: d, hour: 12, minute: 0}, timeZone);
      const w = WEEKDAY_TO_NUM[tzParts(dt, timeZone).weekday];
      if (w === targetWeekday) return `${year}-${pad(month)}-${pad(d)}`;
    }
  } else {
    let count = 0;
    for (let d = 1; d <= dim; d++) {
      const dt = dateFromTZLocal({year, month, day: d, hour: 12, minute: 0}, timeZone);
      const w = WEEKDAY_TO_NUM[tzParts(dt, timeZone).weekday];
      if (w === targetWeekday) {
        count++;
        if (count === rule.occurrence) return `${year}-${pad(month)}-${pad(d)}`;
      }
    }
  }
  return null;
}

function holidayMapForYear(year) {
  const map = new Map();
  for (const h of CONFIG.holidays.fixed) map.set(`${year}-${pad(h.month)}-${pad(h.day)}`, h.name);

  const floatingComputed = new Map();
  for (const r of CONFIG.holidays.floating) {
    if (r.relativeTo) continue;
    const d = computeFloatingHolidayYMD(year, r, CONFIG.timeZone);
    if (d) {
      map.set(d, r.name);
      floatingComputed.set(r.name, d);
    }
  }

  for (const r of CONFIG.holidays.floating) {
    if (!r.relativeTo) continue;
    const base = floatingComputed.get(r.relativeTo);
    if (!base) continue;
    const [Y,M,D] = base.split("-").map(Number);
    const baseDate = dateFromTZLocal({year: Y, month: M, day: D, hour: 12, minute: 0}, CONFIG.timeZone);
    const rel = new Date(baseDate.getTime() + r.offsetDays * 24 * 60 * 60 * 1000);
    const p = tzParts(rel, CONFIG.timeZone);
    map.set(ymd(p), r.name);
  }
  return map;
}

function findActiveTimeOff(todayYMD) {
  for (const entry of CONFIG.timeOff) {
    if (!entry?.start || !entry?.end) continue;
    if (cmpYMD(todayYMD, entry.start) >= 0 && cmpYMD(todayYMD, entry.end) <= 0) return entry;
  }
  return null;
}

function formatCountdown(ms) {
  const total = Math.max(0, Math.floor(ms / 1000));
  const s = total % 60;
  const m = Math.floor(total / 60) % 60;
  const h = Math.floor(total / 3600) % 24;
  const d = Math.floor(total / 86400);
  const parts = [];
  if (d) parts.push(`${d}d`);
  parts.push(`${h}h`, `${m}m`, `${s}s`);
  return parts.join(" ");
}

function setStatus(text, colorVar) {
  $status.textContent = text;
  $status.style.color = `var(${colorVar})`;
}

function nextWorkStartAfter(now) {
  const nowParts = tzParts(now, CONFIG.timeZone);
  let year = nowParts.year, month = nowParts.month, day = nowParts.day;

  for (let i = 0; i < 800; i++) {
    const probe = dateFromTZLocal({year, month, day, hour: 12, minute: 0}, CONFIG.timeZone);
    const p = tzParts(probe, CONFIG.timeZone);
    const probeYMD = ymd(p);

    const holidays = holidayMapForYear(p.year);
    const isHol = holidays.has(probeYMD);
    const wknd = isWeekend(p.weekday);
    const timeOff = findActiveTimeOff(probeYMD);

    if (!wknd && !isHol && !timeOff) {
      const start = dateFromTZLocal({
        year: p.year, month: p.month, day: p.day,
        hour: CONFIG.workStart.h, minute: CONFIG.workStart.m
      }, CONFIG.timeZone);

      if (start.getTime() > now.getTime()) return start;
    }

    const next = new Date(probe.getTime() + 24*60*60*1000);
    const np = tzParts(next, CONFIG.timeZone);
    year = np.year; month = np.month; day = np.day;
  }
  return null;
}

function workEndForDateParts(dateParts) {
  const end = { ...CONFIG.workEnd };
  if (CONFIG.holidays.christmasEveHalfDay) {
    const ymdStr = ymd(dateParts);
    if (ymdStr.endsWith("-12-24")) {
      end.h = CONFIG.holidays.christmasEveEnd.h;
      end.m = CONFIG.holidays.christmasEveEnd.m;
    }
  }
  return end;
}

function render() {
  const now = new Date();
  const p = tzParts(now, CONFIG.timeZone);
  const todayYMD = ymd(p);

  const holidays = holidayMapForYear(p.year);
  const holidayName = holidays.get(todayYMD) || "";
  const wknd = isWeekend(p.weekday);
  const timeOff = findActiveTimeOff(todayYMD);

  const startToday = dateFromTZLocal(
    {year: p.year, month: p.month, day: p.day, hour: CONFIG.workStart.h, minute: CONFIG.workStart.m},
    CONFIG.timeZone
  );
  const endCfg = workEndForDateParts(p);
  const endToday = dateFromTZLocal(
    {year: p.year, month: p.month, day: p.day, hour: endCfg.h, minute: endCfg.m},
    CONFIG.timeZone
  );

  const afterSleep = p.hour >= CONFIG.sleepAfterHour;
  const nextStart = nextWorkStartAfter(now);

  if (timeOff) {
    setStatus("Time Off", "--green");
    const label = timeOff.label ? ` â€” ${timeOff.label}` : "";
    $extra.textContent = `Time off active${label} (${timeOff.start} to ${timeOff.end})`;
    $sub.textContent = nextStart ? `Back to work in ${formatCountdown(nextStart - now)}` : `Back to work: unknown`;
    return;
  }

  if (!wknd && holidayName) {
    setStatus("Not Working", "--green");
    $extra.textContent = `Holiday: ${holidayName}`;
    $sub.textContent = nextStart ? `Back to work in ${formatCountdown(nextStart - now)}` : "Back to work: unknown";
    return;
  }

  if (wknd) {
    setStatus("Weekend", "--green");
    $extra.textContent = "";
    $sub.textContent = nextStart ? `Back to work in ${formatCountdown(nextStart - now)}` : "Back to work: unknown";
    return;
  }

  if (afterSleep) {
    setStatus("Sleeping", "--blue");
    $extra.textContent = "";
    $sub.textContent = nextStart ? `Back to work in ${formatCountdown(nextStart - now)}` : "Back to work: unknown";
    return;
  }

  if (now >= startToday && now < endToday) {
    setStatus("Working", "--red");
    $extra.textContent = (todayYMD.endsWith("-12-24")) ? "Christmas Eve (half day)" : "";
    $sub.textContent = `Off work in ${formatCountdown(endToday - now)}`;
    return;
  }

  setStatus("Not Working", "--green");
  $extra.textContent = (todayYMD.endsWith("-12-24") && now >= endToday) ? "Christmas Eve (half day)" : "";
  $sub.textContent = nextStart ? `Back to work in ${formatCountdown(nextStart - now)}` : "Back to work: unknown";
}

render();
setInterval(render, 250);
</script>
</body>
</html>
